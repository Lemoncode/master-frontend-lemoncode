# Bundle Analyzer

For the next example, let's install and use a bundle analyzer to inspect the internal content of our bundles.

ðŸ“Œ We start from sample `10-code-splitting`.

# Steps to build it

## Prerequisites

Install [Node.js and npm](https://nodejs.org/en/) (20.19.0 || >=22.12.0) if they are not already installed on your computer.

> âš  Verify that you are running at least latest Node LTS version and npm. You can check your current version by running `node -v` and `npm -v` in a terminal/console window. Older versions may produce errors.

## Steps

- We start from `10-code-splitting`. Just copy the project and install:

  ```bash
  npm install
  ```

- Before we proceed with this tool, here goes a brief introduction why they are so useful and widely used:

  > â„¹ï¸ A bundle analyzer or visualizer is a tool that help us to understand the contents of bundles generated by our bundler. It visually displays how modules and dependecies are distributed within the bundle, showing its relationships and the size of each package, allowing us to:
  >
  > - Reduce the final bundle size.
  > - Detect unnecessary or too heavy dependencies.
  > - Improve load times and user experience.
  >
  > These tools are critical to manually increase application performance before we commit to production, and, therefore, they are usually applied over production bundles only.
  >
  > There are different libraries out there, like `vite-bundle-analyzer`, `rollup-plugin-visualizer`, etc. We will use the first one for this sample.

- These tools are usually plug and play, so their usage is as simple as installing it first:

  ```bash
  npm install vite-bundle-analyzer --save-dev
  ```

- And then, use it as a plugin in `vite.config.js`:

  _vite.config.js_

  ```diff
    import { defineConfig } from "vite";
    import checker from "vite-plugin-checker";
    import react from "@vitejs/plugin-react";
    import tailwindcss from "@tailwindcss/vite";
  + import { analyzer } from "vite-bundle-analyzer";

    export default defineConfig({
      plugins: [
        checker({ typescript: true }),
        tailwindcss(),
        react(),
  +     analyzer(),
      ],
    });
  ```

- Let's see what we get out-of-the-box:

  ```bash
  npm run build
  ```

  ðŸ”Ž Check how `localhost:8888` is automatically opened after the build is complete. This is the default behaviour of the package.

  This server renders a report showing an interactive tree map that represents what the the different bundles are made of. It shows every module proportionally to its size.

  You can also expand a search panel to look for specific modules and check its size under different assumptions (gzipped, brotli, etc).

- We can also pass options to the analyzer like:

  ```diff
        react(),
  +     analyzer({
  +       analyzerMode: "static",
  +       openAnalyzer: false,
  +       reportTitle: "Bundle Analysis",
  +       fileName: "bundle-report.html",
  +     }),
      ],
  ```

  > â„¹ï¸ These settings will make analyzer work in static mode instead of server mode. This way, an `html` document is generated with the desired name, we can open it manually, but no server is created.

- And build again:

  ```bash
    npm run build
  ```

## Optional

- Another very interesing analyzer is a rollup plugin to extract bundle statistics. It's called `rollup-plugin-bundle-stats`. Just install it:

  ```bash
  npm install rollup-plugin-bundle-stats --save-dev
  ```

- And now let's configure in vite config file like this:

  ```diff
    import { defineConfig } from "vite";
    import checker from "vite-plugin-checker";
    import react from "@vitejs/plugin-react";
    import tailwindcss from "@tailwindcss/vite";
    import { analyzer } from "vite-bundle-analyzer";
  + import { bundleStats } from "rollup-plugin-bundle-stats";

    export default defineConfig({
      plugins: [
        checker({ typescript: true }),
        tailwindcss(),
        react(),
        analyzer({
          analyzerMode: "static",
          openAnalyzer: false,
          reportTitle: "Bundle Analysis",
          fileName: "bundle-report.html",
        }),
  +     bundleStats(),
      ],
    });
  ```

- Build it again:

  ```bash
    npm run build
  ```

  ðŸ”Ž Check new `bundle-stats.html` page and explore its powerfull features.

- One of the advanced features of this tool is the ability to compare our current build against a baseline build. First of all, we must indicate which run is our baseline. A simple, quick way, is to set an env variable when building our baseline build:

  âš¡ If you are using Linux/Bash, you can run:

  ```bash
  BUNDLE_STATS_BASELINE=true npm run build
  ```

  âš ï¸ Under Window's powershell terminal, you could first set variable for the session and then build it, like:

  ```bash
  $env:BUNDLE_STATS_BASELINE="true"
  ```

  ```bash
  npm run build
  ```

  âš ï¸ Close used terminal in windows to 'unset' env variable.

- Now, let's do a simple exercise, let's copy paste `math.ts` module as `math2.ts`, import it dynamically from `hello.tsx` component by duplicating the button and the handler:

  _src/hello.tsx_

  ```diff
    const applyOperation = async () => {
      const { operate } = await import("./math");
      setCounter(prevCounter => operate(prevCounter));
    };

  + const applyOperation2 = async () => {
  +   const { operate } = await import("./math2");
  +   setCounter(prevCounter => operate(prevCounter));
  + };

    return (
      <>
        <h2>Hello from React</h2>
        <p>Api server is {config.API_BASE}</p>
        <p>Feature A is {config.IS_FEATURE_A_ENABLED ? "enabled" : "disabled"}</p>
        <p>Counter state: {counter}</p>
        <button
          className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
          onClick={applyOperation}
        >
          Apply operation
        </button>
  +     <button
  +       className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
  +       onClick={applyOperation2}
  +     >
  +       Apply operation 2
  +     </button>
  ```

- Now install a new library called 'loglevel':

  ```bash
  npm install loglevel
  ```

- And let's use it in both math modules:

  _src/math.tsx_

  ```diff
  + import log from "loglevel";

  + log.warn("*** Executing lazy-loaded math chunk");

    const randomBetween = (min: number, max: number) =>
  ```

  _src/math2.tsx_

  ```diff
  + import log from "loglevel";

  + log.warn("*** Executing lazy-loaded math2 chunk");

    const randomBetween = (min: number, max: number) =>
  ```

- Run again the build in a clean terminal:

  ```bash
  npm run build
  ```

- ðŸ”Ž Now check the stats again and see how our latest build is compared against the baseline, offering differences in a bunch of stats, mainly size, which allow us to compare any improvement or decline in optimization.

- ðŸ¤¯ It is specially worth mentioning that we won't see any stat related to duplicated code or duplicated modules. We would expect our library `loglevel` to be included in both chunks `math` and `math2`. However, vite is smart enough to avoid duplicates as much as possible by extracting this common library to a separate bundle. Amazing!
